using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Threading.Tasks;
using dotnet5.Records;

namespace dotnet5
{
    static class TopLevelStatement
    {
        public static Task Run()
        {
            var u = new Uri("http://supply-chain-practice-web.supply-chain-practice");
            return Task.CompletedTask;
            var o = new object();
            
            var dict = new HashSet<object>();
            dict.Add(o);
            dict.Add(o);
            dict.Add(new object());
            Console.WriteLine(dict.Count);

            //RunRecordsSample();

            return Task.CompletedTask;
        }

        private static void RunRecordsSample()
        {
            Console.WriteLine("\nRecords");
            
            // positional initialization
            var p = new Person("fn", "ln"); 
            
            // generated by compiler: Person { FirstName = fn, LastName = ln }
            Console.WriteLine(p.ToString());

            var a = new Animal("dog", "gray");
            Console.WriteLine(a.Color); // gray

            var phones = new string[] {"1"};
            var s1 = new Student("name", phones);
            var s2 = new Student("name", phones);
            Console.WriteLine(s1.Equals(s2));   // true
            Console.WriteLine(s1 == s2);        // true
            Console.WriteLine(object.ReferenceEquals(s1, s2));  // false
            
            // deconstruction supported by 
            var (name, phns) = s1;

            // Non-positional properties must have an init or set accessor to be changed in a with expression.
            var s3 = s1 with {Phones = new[] {"2"}};
            Console.WriteLine(object.ReferenceEquals(s1, s3));  // false, copied
        }
    }    
}

